% Regression tests for Simulated ECUs, UDS- and GMLAN Scanners

~ disabled  # These tests take too long for CI

+ Configuration
~ conf

= Imports
load_layer("can", globals_dict=globals())
conf.contribs['CAN']['swap-bytes'] = False
import subprocess, sys, io
import scapy.modules.six as six
from subprocess import call
from scapy.consts import LINUX

= Definition of constants, utility functions and mock classes
iface0 = "vcan0"
iface1 = "vcan1"

# function to exit when the can-isotp kernel module is not available
ISOTP_KERNEL_MODULE_AVAILABLE = False
def exit_if_no_isotp_module():
    if not ISOTP_KERNEL_MODULE_AVAILABLE:
        err = "TEST SKIPPED: can-isotp not available\n"
        sys.__stderr__.write(err)
        warning("Can't test ISOTP native socket because kernel module is not loaded")
        exit(0)


= Initialize a virtual CAN interface
~ vcan_socket needs_root linux
if 0 != call(["cansend", iface0,  "000#"]):
    # vcan0 is not enabled
    if 0 != call(["sudo", "modprobe", "vcan"]):
        raise Exception("modprobe vcan failed")
    if 0 != call(["sudo", "ip", "link", "add", "name", iface0, "type", "vcan"]):
        print("add %s failed: Maybe it was already up?" % iface0)
    if 0 != call(["sudo", "ip", "link", "set", "dev", iface0, "up"]):
        raise Exception("could not bring up %s" % iface0)

if 0 != call(["cansend", iface0,  "000#"]):
    raise Exception("cansend doesn't work")

if 0 != call(["cansend", iface1,  "000#"]):
    # vcan1 is not enabled
    if 0 != call(["sudo", "modprobe", "vcan"]):
        raise Exception("modprobe vcan failed")
    if 0 != call(["sudo", "ip", "link", "add", "name", iface1, "type", "vcan"]):
        print("add %s failed: Maybe it was already up?" % iface1)
    if 0 != call(["sudo", "ip", "link", "set", "dev", iface1, "up"]):
        raise Exception("could not bring up %s" % iface1)

if 0 != call(["cansend", iface1,  "000#"]):
    raise Exception("cansend doesn't work")

print("CAN should work now")

= Import CANSocket

from scapy.contrib.cansocket_python_can import *

new_can_socket = lambda iface: CANSocket(bustype='virtual', channel=iface)
new_can_socket0 = lambda: CANSocket(bustype='virtual', channel=iface0, timeout=0.01)
new_can_socket1 = lambda: CANSocket(bustype='virtual', channel=iface1, timeout=0.01)

# utility function for draining a can interface, asserting that no packets are there
def drain_bus(iface=iface0, assert_empty=True):
    with new_can_socket(iface) as s:
        pkts = s.sniff(timeout=0.1)
        if assert_empty:
            assert len(pkts) == 0

print("CAN sockets should work now")

= Overwrite definition for vcan_socket systems native sockets
~ vcan_socket not_pypy needs_root linux

if six.PY3 and LINUX:
    from scapy.contrib.cansocket_native import *
    new_can_socket = lambda iface: CANSocket(iface)
    new_can_socket0 = lambda: CANSocket(iface0)
    new_can_socket1 = lambda: CANSocket(iface1)


= Overwrite definition for vcan_socket systems python-can sockets
~ vcan_socket needs_root linux
if "python_can" in CANSocket.__module__:
    new_can_socket = lambda iface: CANSocket(bustype='socketcan', channel=iface, bitrate=250000, timeout=0.01)
    new_can_socket0 = lambda: CANSocket(bustype='socketcan', channel=iface0, bitrate=250000, timeout=0.01)
    new_can_socket1 = lambda: CANSocket(bustype='socketcan', channel=iface1, bitrate=250000, timeout=0.01)

= Verify that a CAN socket can be created and closed
s = new_can_socket(iface0)
s.close()


= Check if can-isotp and can-utils are installed on this system
~ linux
p1 = subprocess.Popen(['lsmod'], stdout = subprocess.PIPE)
p2 = subprocess.Popen(['grep', '^can_isotp'], stdout = subprocess.PIPE, stdin=p1.stdout)
p1.stdout.close()
if p1.wait() == 0 and p2.wait() == 0 and b"can_isotp" in p2.stdout.read():
    p = subprocess.Popen(["isotpsend", "-s1", "-d0", iface0], stdin = subprocess.PIPE)
    p.communicate(b"01")
    if p.returncode == 0:
        ISOTP_KERNEL_MODULE_AVAILABLE = True


+ Syntax check

= Import isotp

conf.contribs['ISOTP'] = {'use-can-isotp-kernel-module': ISOTP_KERNEL_MODULE_AVAILABLE}

if six.PY3:
    import importlib
    if "scapy.contrib.isotp" in sys.modules:
        importlib.reload(scapy.contrib.isotp)

load_contrib("isotp", globals_dict=globals())

if six.PY3 and ISOTP_KERNEL_MODULE_AVAILABLE:
    assert ISOTPSocket == ISOTPNativeSocket
else:
    assert ISOTPSocket == ISOTPSoftSocket

############
############
+ Load general modules

= Load contribution layer

load_contrib("automotive.uds", globals_dict=globals())
load_contrib("automotive.gm.gmlan", globals_dict=globals())
load_contrib("automotive.gm.gmlanscan", globals_dict=globals())
load_contrib("automotive.uds_scan", globals_dict=globals())
load_contrib("automotive.ecu", globals_dict=globals())

from scapy.layers.can import *
from scapy.contrib.automotive.ecu import Ecu
from scapy.contrib.isotp import ISOTPMessageBuilder

print("Set delay to lower utilization")
conf.contribs['EcuAnsweringMachine']['send_delay'] = 0.004
conf.contribs['GMLAN']['GMLAN_ECU_AddressingScheme'] = 4

= Load packets from candump

pkts = rdcandump("test/contrib/automotive/uds_ecu_dump.log.gz")
assert len(pkts)

= Create UDS messages from packets

builder = ISOTPMessageBuilder(basecls=UDS, use_ext_addr=False, did=[0x651, 0x641])
msgs = list()

for p in pkts:
    if p.data == b"ECURESET":
        msgs.append(p)
    else:
        builder.feed(p)
        if len(builder):
            msgs.append(builder.pop())

assert len(msgs)

= Create ECU-Clone from packets

mEcu = Ecu(logging=False, verbose=False, store_supported_responses=True)

for p in msgs:
    if isinstance(p, CAN) and p.data == b"ECURESET":
        mEcu.reset()
    else:
        mEcu.update(p)

assert len(mEcu.supported_responses)

= Simulate ECU and run Scanner

with new_can_socket0() as isocan1, ISOTPSocket(isocan1, sid=0x241, did=0x641, basecls=UDS) as ecu, \
        new_can_socket0() as isocan2, ISOTPSocket(isocan2, sid=0x641, did=0x241, basecls=UDS) as tester:
    answering_machine = EcuAnsweringMachine(supported_responses=mEcu.supported_responses, main_socket=ecu, basecls=UDS, verbose=False)
    def reset():
        answering_machine.state.reset()
        answering_machine.state["session"] = 1
    sim = threading.Thread(target=answering_machine, kwargs={'timeout': 500, "stop_filter": lambda x: bytes(x) == b"\xff\xff\xff"})
    sim.start()
    scanner = UDS_Scanner(tester, reset_handler=reset,
                          test_cases=[UDS_ServiceEnumerator, UDS_DSCEnumerator,
                                      UDS_SA_XOR_Enumerator, UDS_WDBISelectiveEnumerator, UDS_TPEnumerator],
                          UDS_DSCEnumerator_kwargs={"timeout": 0.1, "overwrite_timeout": False, "scan_range": range(10)},
                          UDS_ServiceEnumerator_kwargs={"retry_if_busy_returncode": False},
                          UDS_RDBIEnumerator_kwargs={"scan_range": range(0xf800, 0x10000)},
                          UDS_SA_XOR_Enumerator_kwargs={"scan_range": range(10)},
                          delay_state_change=0, timeout=0.1, verbose=True)
    scanner.scan()
    tester.send(b"\xff\xff\xff")
    sim.join(timeout=2)
    assert scanner.scan_completed

scanner.show_testcases_status()
scanner.show_testcases()
assert len(scanner.state_paths) > 3

= Unpickle scanner

import pickle
import gzip

with gzip.open("test/contrib/automotive/uds_ecu_scanner.pkl.gz", "rb") as f:
    backup_scanner = pickle.load(f)  # type: UDS_Scanner

assert len(backup_scanner.configuration.test_cases) == len(scanner.configuration.test_cases)
assert len(backup_scanner.state_paths) == len(scanner.state_paths)

= Pickle scanner

f = io.BytesIO()

pickle.dump(scanner, f)
# If no exception during dump happen.. we reach this line
assert True

= Load packets from candump
pkts = rdcandump("test/contrib/automotive/gmlan_ecu_dump.log.gz")
assert len(pkts)

= Create GMLAN messages from packets
builder = ISOTPMessageBuilder(basecls=GMLAN, use_ext_addr=False, did=[0x247, 0x647])
msgs = list()

for p in pkts:
    if p.data == b"ECURESET":
        msgs.append(p)
    else:
        builder.feed(p)
        if len(builder):
            msgs.append(builder.pop())

assert len(msgs)

= Create ECU-Clone from packets

mEcu = Ecu(logging=False, verbose=False, store_supported_responses=True)

for p in msgs:
    if isinstance(p, CAN) and p.data == b"ECURESET":
        mEcu.reset()
    else:
        mEcu.update(p)

assert len(mEcu.supported_responses)


= Simulate ECU and run Scanner

def securityAccess_Algorithm1(seed):
    return 0xffff & ~seed

keyfunction = securityAccess_Algorithm1

with new_can_socket0() as isocan1, ISOTPSocket(isocan1, sid=0x341, did=0x741, basecls=GMLAN) as ecu, \
        new_can_socket0() as isocan2, ISOTPSocket(isocan2, sid=0x741, did=0x341, basecls=GMLAN) as tester:
    answering_machine = EcuAnsweringMachine(supported_responses=mEcu.supported_responses, main_socket=ecu, basecls=GMLAN, verbose=False)
    def reset():
        answering_machine.state.reset()
        answering_machine.state["session"] = 1
    sim = threading.Thread(target=answering_machine, kwargs={'timeout': 1000, "stop_filter": lambda x: bytes(x) == b"\xff\xff\xff"})
    sim.start()
    es = [GMLAN_ServiceEnumerator, GMLAN_TPEnumerator, GMLAN_IDOEnumerator,
          GMLAN_PMEnumerator, GMLAN_RNOEnumerator, GMLAN_DNCEnumerator,
          GMLAN_RDEnumerator, GMLAN_SA1Enumerator,
          GMLAN_WDBISelectiveEnumerator]
    scanner = GMLAN_Scanner(
        tester, reset_handler=reset, test_cases=es,
        GMLAN_SA1Enumerator_kwargs={"verbose": False, "keyfunction": keyfunction, "timeout": 12})
    scanner.scan()
    tester.send(b"\xff\xff\xff")
    sim.join(timeout=2)

print(scanner.state_paths)
scanner.show_testcases_status()
scanner.show_testcases()
assert len(scanner.state_paths) > 3
assert scanner.scan_completed