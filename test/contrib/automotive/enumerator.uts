% Regression tests for enumerators

+ Load general modules

= Load contribution layer

from scapy.contrib.automotive.enumerator import *
from scapy.contrib.automotive.uds import *
from scapy.contrib.automotive.uds_scan import UDS_Enumerator

from scapy.contrib.automotive.enumerator import _AutomotiveTestCaseScanResult, _AutomotiveTestCaseFilteredScanResult


+ Basic checks
= AutomotiveTestCase basecls checks

pkts = [
    _AutomotiveTestCaseScanResult("s1", UDS(b"\x20abcd"), UDS(b"\x60abcd"), 1.0, 1.9),
    _AutomotiveTestCaseScanResult("s2", UDS(b"\x20abcd"), None, 2.0, None),
    _AutomotiveTestCaseScanResult("s1", UDS(b"\x21abcd"), UDS(b"\x7fabcd"), 3.0, 3.1),
    _AutomotiveTestCaseScanResult("s2", UDS(b"\x21abcd"), UDS(b"\x7fa\x10cd"), 4.0, 4.5),
]

class MyTestCase(AutomotiveTestCase):
    def _get_initial_requests(self, **kwargs):
        # type: (Any) -> Iterable[Packet]
        raise NotImplementedError("Overwrite this method")
    @staticmethod
    def _get_table_entry(tup):
        state, req, res, _, _ = tup
        label = UDS_Enumerator._get_label(res, "PR: Supported")
        return (state,
                "0x%02x: %s" % (req.service, req.sprintf("%UDS.service%")),
                label)
    @staticmethod
    def _get_negative_response_label(response):
        # type: (Packet) -> str
        return response.sprintf("NR: %UDS_NR.negativeResponseCode%")
    @staticmethod
    def _get_negative_response_code(resp):
        # type: (Packet) -> int
        return resp.negativeResponseCode
    @staticmethod
    def _get_negative_response_desc(nrc):
        # type: (int) -> str
        return UDS_NR(negativeResponseCode=nrc).sprintf(
            "%UDS_NR.negativeResponseCode%")


e = MyTestCase()
for p in pkts:
    p.req.time = p.req_ts
    p.req.sent_time = p.req_ts
    if p.resp is not None:
        p.resp.time = p.resp_ts
    e._store_result(p.state, p.req, p.resp)


= AutomotiveTestCase not completed check

assert e.completed == False

= AutomotiveTestCase completed

e._state_completed["s1"] = True
e._state_completed["s2"] = True

assert e.completed

= AutomotiveTestCase stats check

stat_list = e._compute_statistics()

stats = {label: value for state, label, value in stat_list if state == "all"}
print(stats)

assert stats["num_answered"] == '3'
assert stats["num_unanswered"] == '1'
assert stats["answertime_max"] == '0.9'
assert stats["answertime_min"] == '0.1'
assert stats["answertime_avg"] == '0.5'
assert stats["num_negative_resps"] == '2'

= AutomotiveTestCase scanned states

assert len(e.scanned_states) == 2
assert {"s1", "s2"} == e.scanned_states

= AutomotiveTestCase get_label

assert e._get_label(pkts[0].resp) == "PR: PositiveResponse"
assert e._get_label(pkts[0].resp, lambda _: "positive") == "positive"
assert e._get_label(pkts[0].resp, lambda _: "positive" + hex(pkts[0].req.service)) == "positive" + "0x20"
assert e._get_label(pkts[1].resp) == "Timeout"
assert e._get_label(pkts[2].resp) == "NR: 98"
assert e._get_label(pkts[3].resp) == "NR: generalReject"

= AutomotiveTestCase show

e.show(filtered=False)

dump = e.show(dump=True, filtered=False)
assert "NR: 98" in dump
assert "NR: generalReject" in dump
assert "PR: Supported" in dump
assert "Timeout" in dump
assert "s1" in dump
assert "s2" in dump
assert "0x20" in dump
assert "0x21" in dump

= AutomotiveTestCase filtered results before show

print(len(e.filtered_results))
assert len(e.filtered_results) == 2
assert e.filtered_results[0] == pkts[0]
assert e.filtered_results[1] == pkts[2]

= AutomotiveTestCase show filtered

e.show(filtered=True)

dump = e.show(dump=True, filtered=True)
assert "NR: 98" in dump
assert "NR: generalReject" in dump
assert "PR: Supported" in dump
assert "Timeout" not in dump
assert "s1" in dump
assert "s2" in dump
assert "all" in dump
assert "0x20" in dump
assert "0x21" in dump
assert "The following negative response codes are blacklisted: ['serviceNotSupported']" in dump

= AutomotiveTestCase filtered results after show

assert len(e.filtered_results) == 3
assert e.filtered_results[0] == pkts[0]
assert e.filtered_results[1] == pkts[2]

= AutomotiveTestCase supported responses

assert len(e.supported_responses) == 3

= TestCaseExecutor dump check

class MockSock(object):
    def __init__(self):
        self.src = 1
        self.dst = 2
        self.exsrc = 3
        self.exdst = 4

class Scanner(AutomotiveTestCaseExecutor):
    @property
    def tester_present_sender_cls(self):
        # type: () -> Type[PeriodicSenderThread]
        raise NotImplementedError()
    @property
    def default_test_case_clss(self):
        # type: () -> List[Type[AutomotiveTestCaseABC]]
        return [MyTestCase]
    def enter_session(self, session):
        # type: (int) -> bool
        raise NotImplementedError()


+ AutomotiveTestCaseExecutorConfiguration tests

= Basic tests

class TestCase1(MyTestCase):
    pass

class TestCase2(MyTestCase):
    pass

tce = Scanner(MockSock(), test_cases=[TestCase1, TestCase2, MyTestCase],
              verbose=True, delay_state_change=42,
              global_arg="Whatever", TestCase1_kwargs={"local_kwarg": 42})

config = tce.configuration  # type: AutomotiveTestCaseExecutorConfiguration
assert config.delay_state_change == 42
assert config.verbose == True
assert len(config.test_cases) == 3
assert len(config.TestCase1.items()) == 4
assert len(config.TestCase2.items()) == 3
assert len(config["TestCase1"].items()) == 4
assert len(config.MyTestCase.items()) == 3
assert config.TestCase1["verbose"] == True
assert config.TestCase1["local_kwarg"] == 42
assert config.TestCase1["global_arg"] == "Whatever"
assert config.TestCase2["global_arg"] == "Whatever"
assert config.MyTestCase["global_arg"] == "Whatever"
